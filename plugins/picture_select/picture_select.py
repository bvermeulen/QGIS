# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PictureSelect
                                 A QGIS plugin
 Draws rubberband and displays the pictures within the rectangle
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-09-14
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Bruno Vermeulen
        email                : bruno.vermeulen@hotmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from pathlib import Path
from qgis.PyQt.QtCore import Qt, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction

from qgis.core import (
    QgsProject,
    QgsFeatureRequest,
    QgsPointXY,
    QgsCoordinateTransform,
    QgsCoordinateReferenceSystem,
    QgsRectangle,
    QgsWkbTypes,
)
from qgis.gui import (
    QgsMapToolEmitPoint,
    QgsVertexMarker,
    QgsRubberBand,
)
from .pyqt_picture import Mode, PictureShow

# Initialize Qt resources from file resources.py
from .resources import qInitResources

qInitResources()

from .picture_select_dlg import PictureSelectDialog, START_YEAR, END_YEAR, GEO_ITEMS

year_range = range(START_YEAR, END_YEAR + 1)


class SelectFilterPictureLayer:
    def __init__(self, years_selected, geo_info):
        pictures_layer = "picture year"
        try:
            self.layer = QgsProject.instance().mapLayersByName(pictures_layer)[0]
        except IndexError:
            return

        self.tr_wgs = QgsCoordinateTransform(
            QgsCoordinateReferenceSystem(QgsProject.instance().crs().authid()),
            QgsCoordinateReferenceSystem("EPSG:4326"),
            QgsProject.instance().transformContext(),
        )
        self.layer.setSubsetString(self.build_query_string(years_selected, geo_info))

    @staticmethod
    def build_query_string(years_selected, geo_info):
        # make subselection of years; add dummy year 9999 if list is empty
        # if year 2010 is selected then add all years less than 2011
        years = [year for year, val in years_selected.items() if val and year != 2010]
        years = years if years else [9999]
        query_str = f"(\"year\" in ({','.join(str(y) for y in years)})"
        query_str += f' or "year" < 2011)' if years_selected[2010] else ")"

        # add geolocation filter
        for geo_key, subkeys in GEO_ITEMS.items():
            pattern = "|".join(c.strip() for c in geo_info[geo_key].split(","))
            if not pattern:
                continue
            if len(subkeys) == 1:
                query_str += f" and {subkeys[0]} ~* '{pattern}'"
            else:
                query_str += (
                    f" and ({subkeys[0]} ~* '{pattern}' or {subkeys[1]} ~* '{pattern}')"
                )

        return query_str

    def select_pics_in_rectangle(self, start_point, end_point):
        if start_point is None or end_point is None:
            return []

        elif start_point.x() == end_point.x() or start_point.y() == end_point.y():
            return []

        start_point = self.tr_wgs.transform(start_point)
        end_point = self.tr_wgs.transform(end_point)
        select_area = QgsRectangle(start_point, end_point)
        self.request = QgsFeatureRequest().setFilterRect(select_area)
        picture_ids = []
        for feature in self.layer.getFeatures(self.request):
            picture_ids.append(feature.attributes()[2])
        return picture_ids

    def get_mappoint(self, pic_id):
        for feature in self.layer.getFeatures(self.request):
            if pic_id == feature.attributes()[2]:
                return self.tr_wgs.transform(
                    feature.geometry().asPoint(),
                    QgsCoordinateTransform.ReverseTransform,
                )
        return None


class SelectMapTool(QgsMapToolEmitPoint):
    def __init__(self, canvas, years_selected, geo_info):
        self.canvas = canvas
        QgsMapToolEmitPoint.__init__(self, self.canvas)

        self.filtered_pic_layer = SelectFilterPictureLayer(years_selected, geo_info)

        self.rubberBand = QgsRubberBand(self.canvas)
        self.rubberBand.setColor(Qt.blue)
        self.rubberBand.setFillColor(Qt.transparent)
        self.rubberBand.setWidth(2)

        self.marker = None
        self.pic_show = None
        self.reset()

    def reset(self):
        self.startPoint = self.endPoint = None
        self.isEmittingPoint = False
        self.rubberBand.reset()
        self.pic_id = None
        self.canvas.scene().removeItem(self.marker)

        if self.pic_show:
            self.pic_show.cntr_quit()
            self.pic_show = None

    def canvasPressEvent(self, e):
        self.reset()
        self.start_point = self.toMapCoordinates(e.pos())
        self.end_point = self.start_point
        self.isEmittingPoint = True
        self.show_rect(self.start_point, self.end_point)

    def canvasReleaseEvent(self, e):
        self.isEmittingPoint = False
        pic_ids = self.filtered_pic_layer.select_pics_in_rectangle(
            self.start_point, self.end_point
        )

        if pic_ids:
            self.pic_show = PictureShow(mode=Mode.Multi)
            self.pic_show.selected_id_changed.connect(self.show_marker)
            self.pic_show.call_by_list(pic_ids)

    def canvasMoveEvent(self, e):
        if not self.isEmittingPoint:
            return

        self.end_point = self.toMapCoordinates(e.pos())
        self.show_rect(self.start_point, self.end_point)

    def show_rect(self, start_point, end_point):
        self.rubberBand.reset(QgsWkbTypes.PolygonGeometry)
        if start_point.x() == end_point.x() or start_point.y() == end_point.y():
            return

        self.rubberBand.addPoint(QgsPointXY(start_point.x(), start_point.y()), False)
        self.rubberBand.addPoint(QgsPointXY(start_point.x(), end_point.y()), False)
        self.rubberBand.addPoint(QgsPointXY(end_point.x(), end_point.y()), False)
        # true to update canvas
        self.rubberBand.addPoint(QgsPointXY(end_point.x(), start_point.y()), True)
        self.rubberBand.show()

    def show_marker(self, _id):
        point = self.filtered_pic_layer.get_mappoint(_id)
        if point:
            self.canvas.scene().removeItem(self.marker)
            self.marker = QgsVertexMarker(self.canvas)
            self.marker.setColor(Qt.yellow)
            self.marker.setIconSize(6)  # or ICON_BOX, ICON_X
            self.marker.setIconType(QgsVertexMarker.ICON_CROSS)
            self.marker.setPenWidth(3)
            self.marker.setCenter(point)
            self.marker.show()

    def deactivate(self):
        self.reset()


class PictureSelect:
    def __init__(self, iface):
        self.iface = iface
        self.actions = []
        self.menu = self.tr("&Picture Select")
        self.first_start = None
        self.select_pic = None
        self.years_selection = {year: True for year in year_range}
        self.geo_info = {geo_info: "" for geo_info in GEO_ITEMS}

    def initGui(self):
        icon_path = str(Path(__file__).parent / "icon.png")
        self.add_action(
            icon_path,
            text=self.tr("Picture Select"),
            callback=self.run,
            parent=self.iface.mainWindow(),
        )

        self.first_start = True

    def tr(self, message):
        return QCoreApplication.translate("PictureSelect", message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        checkable=True,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None,
    ):
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if checkable:
            action.setCheckable(True)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(self.menu, action)

        self.actions.append(action)

        return action

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(self.tr("&Picture Select"), action)
            self.iface.removeToolBarIcon(action)

    def run(self):
        try:
            self.select_pic.deactivate()

        except AttributeError:
            pass

        result = False
        if self.first_start:
            self.first_start = False
            dlg = PictureSelectDialog()
            for year, val in self.years_selection.items():
                getattr(dlg, f"cb_{year}").setChecked(val)
            for geo_item, val in self.geo_info.items():
                getattr(dlg, f"le_{geo_item}").setText(val)
            dlg.show()
            result = dlg.exec_()

        if result:
            for year in self.years_selection:
                self.years_selection[year] = getattr(dlg, f"cb_{year}").isChecked()
            for geo_item in GEO_ITEMS:
                self.geo_info[geo_item] = getattr(dlg, f"le_{geo_item}").text()
            dlg.close()

        if self.actions[0].isChecked():
            canvas = self.iface.mapCanvas()
            self.select_pic = SelectMapTool(canvas, self.years_selection, self.geo_info)
            canvas.setMapTool(self.select_pic)

        else:
            self.select_pic.deactivate()
            self.iface.mapCanvas().unsetMapTool(self.select_pic)
            self.first_start = True
